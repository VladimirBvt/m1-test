### Проблемы и решения:
1. Очистка интервалов в useData при дестрое компонента
2. Максимально типизировать код
3. Покрыть тестами
4. Также хорошо бы закрепить контракт ответа с сервера.
   Можно использовать Swagger, c возможностью отдачи контракта в json
5. Использовать архитектуру FSD с адаптацией под нужды проекты
6. Слишком большой объем данных, необходимо разбить их с помощью пагинации или частичной подгрузки по частям, например ленивая подгрузка при скролле
7. Установить и настроить Prettier и Linter
8. Проп isactive именуется не в кэмел кейсе
9. В компонент ListItem передавать слотом проп Button вместо прямого импорта для улучшения архитектуры приложения
10. Вынести компонент SubTitle в отдельный файл и изменить в нем проп на явный текст с типом string
11. Лучше закешировать ответ от сервера, особенно для списка, чтобы каждый переход на список не создавал новый запрос
12. В зависимостях useEffect был filteredItems, который обновлялся внутри этого эффекта, вызывая тем самым кольцевую зависимость на каждый рендер
13. Исправлена ошибка в условии добавления активного id в списке, в связи с которой id=0 не добавлялся из-за его falsy значения
14. В хуке useSort мутировался массив items. Спред оператором создали новый массив, который отсортировали. Также не верный порядок сортировки.
15. Убраны лишние useEffect'ы
16. Для избегания задержки в инпуте ввода строки поиска добавлен useDefferedValue, теперь обновляется список немного с задержкой
17. Тот же прием применил для кнопки изменения сортировки с ее дизейблом.
18. Обработаны ошибки получения данных, обернут компонент в ErrorBoundary для перехвата ошибок
19. Также надо обрабатывать ошибки в запросе списка items
20. Правильнее было бы делать маленькие атомарные коммиты

Большая часть проблем решена в коде.
